    def param_scanner(self, param_vals, param_list, unit_dict,percent, title):
        unit_list=[unit_dict[k] for k in param_list]
        current_optim_list=self.optim_list
        self.optim_list=param_list
        num_params=len(param_list)
        for i in range(1, num_params):
            if num_params%i==0:
                col=i

        pc_change=[1-percent, 1, 1+percent]
        rows=num_params/col
        first_elem=((np.arange(0, rows)*col))
        bottom_elem=np.arange((rows*col)-col, rows*col)
        for i in range(0, num_params):
            ax=plt.subplot(rows, col, i+1)
            if i in first_elem:
                ax.set_ylabel("Current(A)")
            else:
                ax.axes.get_yaxis().set_ticks([])
            if i in bottom_elem:
                ax.set_xlabel("Voltage(V)")
            else:
                ax.axes.get_xaxis().set_ticks([])
            true_val=param_vals[i]
            plt.title(param_list[i])
            for j in range(0,3):
                var_val=true_val*pc_change[j]
                param_vals[i]=var_val
                time_series=self.test_vals(param_vals, "timeseries", test=False)
                voltages=self.define_voltages()
                plt.plot(self.e_nondim(voltages), alpha=0.7)#
            plt.plot(self.e_nondim(self.other_values["experiment_voltage"]))
            param_vals[i]=true_val
            plt.legend()
        plt.suptitle(title)
        self.optim_list=current_optim_list
        plt.show()



    def likelihood_plots(self,times, voltages, data, simulation, method):
        if method=="real":
            returner=np.real
        elif method=="imag":
            returner=np.imag
        elif method=="abs":
            returner=abs
        elif method=="Total":
            returner=self.empty
        times=self.t_nondim(times)
        data=self.i_nondim(data)
        simulation=self.i_nondim(simulation)
        plt.subplot(2,2,1)
        plt.plot(self.e_nondim(voltages), data, label="data")
        plt.plot(self.e_nondim(voltages), simulation, label="simulation")
        plt.xlabel("Voltage(V)")
        plt.ylabel("Current(A)")
        plt.title("Time series")
        plt.legend()
        plt.subplot(2,2,2)
        filtered_data=self.kaiser_filter(data, method=method)
        filtered_sim=self.kaiser_filter(simulation, method=method)
        plt.plot(self.frequencies[self.freq_idx], filtered_data[self.freq_idx], label="data")
        plt.plot(self.frequencies[self.freq_idx],filtered_sim[self.freq_idx] , label="simulation")
        plt.xlabel("Frequency(Hz)")
        plt.ylabel("Amplitude")
        plt.title("Likelihood function (" +str(self.harmonic_range[0])+"-"+str(self.harmonic_range[-1])+"harmonics)")
        plt.legend()
        plt.subplot(2,2,3)
        plt.plot(np.fft.ifft(filtered_data),label="data")
        plt.plot(np.fft.ifft(filtered_sim), label="simulation")
        plt.ylabel("Current(A)")
        plt.title("Inverse fft of likelihood function")
        plt.legend()
        plt.subplot(2,2,4)
        hann=np.hanning(len(data))
        data=np.multiply(data, hann)
        sim=np.multiply(data, hann)
        f_data=returner(np.fft.fft(data))
        f_sim=returner(np.fft.fft(sim))
        plt.plot(times, np.fft.ifft(f_data), label="data")
        plt.plot(times, np.fft.ifft(f_sim), label="simulation")
        plt.legend()
        plt.xlabel("Time(s)")
        plt.ylabel("Current(A)")
        plt.title("Inverse fft of "+method+"-valued Fourier transform")
        plt.legend()
        plt.suptitle("Method="+method)
        plt.show()


    def kaiser_filter(self, time_series, method="real"):
        frequencies=self.frequencies
        L=len(time_series)
        window=np.hanning(L)
        time_series=np.multiply(time_series, window)
        self.f=np.fft.fftfreq(len(time_series), self.time_vec[1]-self.time_vec[0])
        Y=np.fft.fft(time_series)
        #Y_pow=np.power(copy.deepcopy(Y[0:len(frequencies)]),2)
        top_hat=copy.deepcopy(Y[0:len(frequencies)])

        true_harm=self.nd_param.omega*self.nd_param.c_T0
        if sum(np.diff(self.harmonic_range))!=len(self.harmonic_range)-1:
            results=np.zeros(len(top_hat), dtype=complex)
            for i in range(0, self.num_harmonics):
                true_harm_n=true_harm*self.harmonic_range[i]
                index=[np.where((frequencies<(true_harm_n+(self.nd_param.omega*self.filter_val))) & (frequencies>true_harm_n-(self.nd_param.omega*self.filter_val)))]
                filter_bit=top_hat[index]
                results[index]=filter_bit
        else:
            if self.harmonic_range[-1]<15:
                likelihood=top_hat[self.freq_idx]
                results=np.zeros(len(top_hat), dtype=complex)
                results[self.freq_idx]=likelihood
            else:
                results=Y[0:len(time_series)/2]

        if method=="real":
            returner=np.real
        elif method=="imag":
            returner==np.imag
        elif method=="abs":
            returner=abs
        elif method=="Total":
            returner=self.empty
            results=np.append((np.real(results)), np.imag(results))

        return (returner(results))



for i in range(0, num_runs):
    found_parameters, found_value=pints.optimise(
                                                score,
                                                x0,
                                                boundaries=CMAES_boundaries,
                                                method=pints.CMAES
                                                )
    cmaes_results=noramp_fit.change_norm_group(found_parameters, "un_norm")
    param_mat[i,:]=cmaes_results
    score_vec[i]=found_value

best_idx=np.where(score_vec==min(score_vec))
best_idx=best_idx[0][0]
cmaes_results=param_mat[best_idx, :]

print list(cmaes_results)
cmaes_time=noramp_fit.test_vals(cmaes_results, likelihood="timeseries", test=False)
plt.plot(voltage_results, cmaes_time)
plt.plot(voltage_results, current_results)
plt.show()
#error=np.std(np.subtract(cmaes_prediction, likelihood_func))

error=np.std(np.subtract(cmaes_time, current_results))
mcmc_problem=pints.SingleOutputProblem(noramp_fit, time_results, current_results)
#mcmc_problem=pints.SingleOutputProblem(noramp_fit, time_results, current_results)
updated_lb=np.append(cmaes_results*0.75, [0])#found_parameters[3]*0.97,
updated_ub=np.append(cmaes_results*1.25, [2*error])#found_parameters[3]*1.03,
updated_boundaries=[updated_lb, updated_ub]
updated_boundaries=np.sort(updated_boundaries, 0)

noramp_fit.define_boundaries(updated_boundaries)
log_liklihood=pints.UnknownNoiseLogLikelihood(mcmc_problem)
log_prior=pints.UniformLogPrior(updated_boundaries[0],
                                updated_boundaries[1])
log_posterior=pints.LogPosterior(log_liklihood, log_prior)
mcmc_parameters=np.append(cmaes_results, error)
xs=[mcmc_parameters,
    mcmc_parameters,
    mcmc_parameters
    ]
noramp_fit.simulation_options["label"]="MCMC"
mcmc = pints.MCMCSampling(log_posterior, 3, xs,method=pints.AdaptiveCovarianceMCMC)
mcmc.set_max_iterations(10000)
chains=mcmc.run()
f=open("GC4_MCMC_chains.txt", "w")
np.save(f, chains)
f.close()
pints.plot.trace(chains)
plt.show()


